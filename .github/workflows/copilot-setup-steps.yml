name: 'Copilot Setup Steps'

# This workflow sets up a complete development environment for the PowerShell module project
# when executed by GitHub Copilot Agent for development assistance.

on:
  workflow_dispatch:
  pull_request:
    paths:
      - '.github/workflows/copilot-setup-steps.yml'
  push:
    paths:
      - '.github/workflows/copilot-setup-steps.yml'

# cSpell: ignore unshallow LASTEXITCODE PSDSC noreport dearmor distro keyrings endgroup libmi libc
jobs:
  copilot-setup-steps:
    name: Setup PowerShell Development Environment
    runs-on: ubuntu-latest

    permissions:
      contents: read

    steps:
      - name: Set Environment Variables
        shell: bash
        run: |
          echo "Setting MODULE_NAME=$MODULE_NAME to GitHub environment"
          echo "MODULE_NAME=$MODULE_NAME" >> "$GITHUB_ENV"
        env:
          MODULE_NAME: 'SqlServerDsc'

      - name: Checkout Repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Full history needed for GitVersion

      # This step is needed for GitVersion because Copilot switches to its working branch
      # after checkout and fetches only depth 2.
      - name: Ensure full history for GitVersion
        shell: pwsh
        run: |
          Write-Host 'Ensuring full history for GitVersion...'

          $isShallow = (& git rev-parse --is-shallow-repository) -eq 'true'

          if ($isShallow)
          {
              Write-Host 'Repository is shallow. Fetching full history and tags...'

              git fetch --prune --unshallow --tags --no-recurse-submodules

              if ($LASTEXITCODE -ne 0)
              {
                  throw 'git fetch --unshallow failed'
              }
          }
          else
          {
              Write-Host 'Repository is not shallow. Refreshing tags...'

              git fetch --prune --tags --no-recurse-submodules

              if ($LASTEXITCODE -ne 0)
              {
                  throw 'git fetch --tags failed'
              }
          }

          Write-Host 'History ready for GitVersion.'

      - name: Install Linux Dependencies
        shell: bash
        run: |
          echo "Installing Linux dependencies for PowerShell DSC..."

          # Update package list
          echo "::group::Update package list"
          echo "Updating package list..."
          sudo apt-get update
          echo "Package list updated successfully"
          echo "::endgroup::"

          # Ensure gpg is available
          sudo apt-get install -y gnupg

          # Check if Microsoft repository is already added, if not add it
          if ! grep -q "packages.microsoft.com" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null; then
            echo "::group::Add Microsoft repository"
            echo "Adding Microsoft repository..."
            # Add Microsoft's GPG key and repository (keyring)
            sudo install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | sudo tee /etc/apt/keyrings/microsoft.gpg >/dev/null
            sudo chmod a+r /etc/apt/keyrings/microsoft.gpg
            DISTRO_CODENAME="$(lsb_release -cs)"
            echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/microsoft-ubuntu-${DISTRO_CODENAME}-prod ${DISTRO_CODENAME} main" | sudo tee "/etc/apt/sources.list.d/microsoft-${DISTRO_CODENAME}-prod.list" >/dev/null

            # Update package list again after adding the new repo
            echo "Updating package list after adding Microsoft repository..."
            if ! sudo apt-get update; then
              echo "::warning::apt-get update failed after adding Microsoft repo (repo may be unavailable for this distro). Continuing..."
            fi
            echo "Microsoft repository added successfully"
            echo "::endgroup::"
          else
            echo "Microsoft repository already configured, skipping..."
          fi

          # Install OMI (Open Management Infrastructure) which provides libmi
          echo "::group::Install OMI and dependencies"
          if apt-cache policy omi 2>/dev/null | grep -q 'Candidate:'; then
            echo "Installing OMI package..."

            # Set a shorter hostname to avoid SSL certificate generation errors
            # OMI generates SSL certificates during installation and GitHub Actions runners
            # often have very long hostnames that exceed the 64-character limit for CN fields
            echo "Setting temporary hostname to avoid SSL certificate generation errors..."
            ORIGINAL_HOSTNAME=$(hostname)

            # Install trap to always restore hostname on EXIT or ERR
            restore_hostname() {
              echo "Restoring original hostname..."
              sudo hostname "$ORIGINAL_HOSTNAME"
              trap - EXIT ERR  # Remove the trap after restore
            }
            trap 'restore_hostname' EXIT ERR

            sudo hostname "dsc-runner"

            if ! sudo apt-get install -y omi; then
              echo "OMI package failed to install; continuing..."
              echo "::warning::OMI package failed to install; continuing without OMI"
            else
              echo "OMI package installed successfully"
            fi

            # Restore original hostname and remove trap
            restore_hostname
          else
            echo "Package 'omi' not found in repositories; skipping OMI install."
            echo "::warning::OMI package not found in repositories, skipping installation"
          fi
          echo "::endgroup::"

          echo "::group::Installing additional development dependencies..."
          echo "Installing development dependencies..."
          sudo apt-get install -y libc6-dev libssl-dev tree
          echo "Development dependencies installed successfully"
          echo "::endgroup::"

          # Set LD_LIBRARY_PATH permanently for the runner session
          echo "Setting LD_LIBRARY_PATH environment variable..."
          echo "LD_LIBRARY_PATH=/opt/omi/lib:/usr/lib/x86_64-linux-gnu:${LD_LIBRARY_PATH}" >> "$GITHUB_ENV"
          echo "Environment variable set successfully"

          echo "Linux dependencies installed successfully"

      - name: Configure PowerShell Environment
        shell: pwsh
        run: |
          Write-Host "Configure PowerShell environment..."

          # Install dependent PowerShell modules
          Write-Host "Installing SqlServer module..."
          Install-PSResource -Name 'SqlServer' -Version '21.1.18256' -Scope 'CurrentUser' -Repository 'PSGallery' -TrustRepository
          Write-Host "SqlServer module installed successfully"

          Write-Host "Installing PSDSC module..."
          Install-PSResource -Name 'PSDSC' -Scope 'CurrentUser' -Repository 'PSGallery' -TrustRepository
          Write-Host "PSDSC module installed successfully"

          Write-Host "PowerShell environment configuration complete"

      - name: Install DSCv3
        shell: pwsh
        run: |
          Write-Host "Install DSCv3 in environment..."

          # Install dependent PowerShell modules
          Write-Host "Installing DSCv3 executable..."
          Install-DscExe -IncludePrerelease -Force
          Write-Host "DSCv3 installed successfully"

          Write-Host "DSCv3 install complete"

      - name: Verify DSCv3
        shell: pwsh
        run: |
          Write-Host "Running DSCv3 to validate correct operation..."
          dsc --version

      - name: Install .NET Tools
        shell: pwsh
        run: |
          Write-Host 'Installing/Updating .NET tools...'

          # Install GitVersion for semantic versioning (idempotent)
          dotnet tool update --global GitVersion.Tool --version 5.* `
            || dotnet tool install --global GitVersion.Tool --version 5.*

          # Verify installation
          dotnet-gitversion /version

          Write-Host '.NET tools ready.'

      - name: Verify GitVersion
        shell: pwsh
        run: |
          Write-Host 'Running GitVersion to determine semantic version (parsing to PowerShell object)...'
          dotnet-gitversion | ConvertFrom-Json

      - name: Resolve Dependencies
        shell: pwsh
        run: |
          Write-Host 'Resolving project dependencies...'

          # Run dependency resolution
          ./build.ps1 -ResolveDependency -Tasks 'noop' -UseModuleFast -ErrorAction Stop

          Write-Host 'Dependencies resolved successfully.'

      - name: Build Module
        shell: pwsh
        run: |
          Write-Host "Building $env:MODULE_NAME module..."

          # Build the module
          ./build.ps1 -Tasks 'build' -ErrorAction Stop

          # Verify build output
          $builtPath = "output/builtModule/$env:MODULE_NAME"
          if (Test-Path -Path $builtPath)
          {
              Write-Host "Module built successfully at: $builtPath"
              # Show files with paths relative to the built module base path using `tree` (run directly in PowerShell)
              $base = (Resolve-Path -Path $builtPath).ProviderPath
              Write-Host "Files under $base (relative paths):"

              # Run tree directly and strip leading './' from its output
              tree --noreport $builtPath
          }
          else
          {
              Write-Error 'Module build failed - output directory not found'
              exit 1
          }

      - name: Import Built Module
        shell: pwsh
        run: |
          Write-Host "Importing built $env:MODULE_NAME module..."

          ./build.ps1 -Tasks 'noop'
          Import-Module -Name $env:MODULE_NAME -Force

          # Verify module is loaded
          $module = Get-Module -Name $env:MODULE_NAME -ErrorAction SilentlyContinue

          if ($module)
          {
              Write-Host 'Module imported successfully:'
              Write-Host "  Name: $($module.Name)"
              Write-Host "  Version: $($module.Version)"
              Write-Host "  Path: $($module.Path)"

              # Show available commands
              $commands = @(Get-Command -Module $env:MODULE_NAME)
              if ($commands.Count -gt 0)
              {
                  Write-Host "  Exported Commands: $($commands.Count)"
                  Write-Host "`nAvailable Commands:"

                  $commands |
                    Select-Object Name, ModuleName | Format-Table -AutoSize
              }
              else
              {
                  Write-Host 'No commands exported by the module.'
              }

              $dscResources = @(dsc resource list --adapter Microsoft.DSC/PowerShell --output-format json | ConvertFrom-Json)
              Write-Host "`n  Available class-based DSC Resources: $($dscResources.Count)`n"
              $dscResources | Format-Table type, capabilities, implementedAs, requireAdapter -GroupBy kind -AutoSize
          }
          else
          {
              Write-Error 'Failed to import module'

              exit 1
          }
